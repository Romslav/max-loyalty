import { io, Socket } from 'socket.io-client';\nimport { useNotificationStore } from '@stores/notificationStore';\n\ninterface WebSocketConfig {\n  url: string;\n  reconnection: boolean;\n  reconnectionDelay: number;\n  reconnectionDelayMax: number;\n  maxReconnectionAttempts: number;\n}\n\nclass WebSocketService {\n  private socket: Socket | null = null;\n  private config: WebSocketConfig;\n  private messageQueue: any[] = [];\n  private isConnected: boolean = false;\n  private listeners: Map<string, Set<Function>> = new Map();\n\n  constructor(config?: Partial<WebSocketConfig>) {\n    this.config = {\n      url: import.meta.env.VITE_WS_URL || 'ws://localhost:3000',\n      reconnection: true,\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 5000,\n      maxReconnectionAttempts: 5,\n      ...config,\n    };\n  }\n\n  /**\n   * Connect to WebSocket server with JWT token\n   */\n  connect(token: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        if (this.socket?.connected) {\n          resolve();\n          return;\n        }\n\n        const socketUrl = this.config.url.replace(/\\/$/, '');\n        this.socket = io(socketUrl, {\n          auth: {\n            token,\n          },\n          reconnection: this.config.reconnection,\n          reconnectionDelay: this.config.reconnectionDelay,\n          reconnectionDelayMax: this.config.reconnectionDelayMax,\n          maxReconnectionAttempts: this.config.maxReconnectionAttempts,\n          transports: ['websocket', 'polling'],\n        });\n\n        this.setupEventListeners();\n\n        this.socket.on('connect', () => {\n          this.isConnected = true;\n          console.log('[WebSocket] Connected to server');\n          this.flushMessageQueue();\n          resolve();\n        });\n\n        this.socket.on('connect_error', (error) => {\n          console.error('[WebSocket] Connection error:', error);\n          reject(error);\n        });\n      } catch (error) {\n        console.error('[WebSocket] Connect error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Disconnect from WebSocket server\n   */\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.isConnected = false;\n      this.listeners.clear();\n      console.log('[WebSocket] Disconnected from server');\n    }\n  }\n\n  /**\n   * Subscribe to specific event channel\n   */\n  subscribe(\n    type: 'guest_card' | 'points_operations' | 'system_events' | 'restaurant_transactions',\n    data: Record<string, any>\n  ): void {\n    this.emit('subscribe', { type, data });\n  }\n\n  /**\n   * Unsubscribe from event channel\n   */\n  unsubscribe(\n    type: 'guest_card' | 'points_operations' | 'system_events' | 'restaurant_transactions',\n    data: Record<string, any>\n  ): void {\n    this.emit('unsubscribe', { type, data });\n  }\n\n  /**\n   * Listen to specific event\n   */\n  on(event: string, callback: (data: any) => void): () => void {\n    if (!this.socket) {\n      console.warn('[WebSocket] Socket not initialized');\n      return () => {};\n    }\n\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)?.add(callback);\n\n    this.socket.on(event, callback);\n\n    // Return unsubscribe function\n    return () => {\n      this.socket?.off(event, callback);\n      this.listeners.get(event)?.delete(callback);\n    };\n  }\n\n  /**\n   * Listen to event once\n   */\n  once(event: string, callback: (data: any) => void): void {\n    if (!this.socket) {\n      console.warn('[WebSocket] Socket not initialized');\n      return;\n    }\n\n    this.socket.once(event, callback);\n  }\n\n  /**\n   * Emit event to server\n   */\n  emit(event: string, data?: any): void {\n    if (!this.socket) {\n      console.warn('[WebSocket] Socket not initialized');\n      return;\n    }\n\n    if (this.isConnected) {\n      this.socket.emit(event, data);\n    } else {\n      // Queue message if not connected\n      this.messageQueue.push({ event, data });\n      console.log('[WebSocket] Message queued:', event);\n    }\n  }\n\n  /**\n   * Emit event and wait for response (acknowledgement)\n   */\n  async request<T = any>(\n    event: string,\n    data?: any,\n    timeout: number = 5000\n  ): Promise<T> {\n    return new Promise((resolve, reject) => {\n      if (!this.socket?.connected) {\n        reject(new Error('WebSocket not connected'));\n        return;\n      }\n\n      const timer = setTimeout(\n        () => reject(new Error('Request timeout')),\n        timeout\n      );\n\n      this.socket.emit(event, data, (response: T) => {\n        clearTimeout(timer);\n        resolve(response);\n      });\n    });\n  }\n\n  /**\n   * Get connection status\n   */\n  isActive(): boolean {\n    return this.isConnected && this.socket?.connected;\n  }\n\n  /**\n   * Get socket ID\n   */\n  getSocketId(): string | undefined {\n    return this.socket?.id;\n  }\n\n  /**\n   * Setup global event listeners\n   */\n  private setupEventListeners(): void {\n    if (!this.socket) return;\n\n    // Connection events\n    this.socket.on('connected', (data) => {\n      console.log('[WebSocket] Connected event received:', data);\n      this.emit('_system_connected', data);\n    });\n\n    this.socket.on('disconnected', (data) => {\n      this.isConnected = false;\n      console.log('[WebSocket] Disconnected event received:', data);\n      this.emit('_system_disconnected', data);\n    });\n\n    // Error handling\n    this.socket.on('error', (data) => {\n      console.error('[WebSocket] Error event:', data);\n      this.emit('_system_error', data);\n    });\n\n    // Connection error\n    this.socket.on('connect_error', (error) => {\n      console.error('[WebSocket] Connect error:', error);\n    });\n  }\n\n  /**\n   * Flush queued messages after reconnection\n   */\n  private flushMessageQueue(): void {\n    while (this.messageQueue.length > 0) {\n      const { event, data } = this.messageQueue.shift();\n      this.emit(event, data);\n    }\n    console.log('[WebSocket] Message queue flushed');\n  }\n}\n\n// Singleton instance\nexport const websocketService = new WebSocketService();\n