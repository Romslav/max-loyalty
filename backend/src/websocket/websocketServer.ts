import { Server as SocketIOServer, Socket } from 'socket.io';\nimport { Server as HTTPServer } from 'http';\nimport jwt from 'jsonwebtoken';\n\nexport interface AuthSocket extends Socket {\n  userId: string;\n  role: 'admin' | 'restaurant' | 'cashier' | 'guest';\n  restaurantId?: string;\n  authenticated: boolean;\n}\n\ninterface BroadcastEventPayload {\n  guestId?: string;\n  restaurantId?: string;\n  cardId?: string;\n  amount: number;\n  timestamp: number;\n  [key: string]: any;\n}\n\nexport class WebSocketServer {\n  private io: SocketIOServer;\n  private connectedUsers = new Map<string, Set<string>>();\n  private userRoles = new Map<string, string>();\n\n  constructor(httpServer: HTTPServer) {\n    this.io = new SocketIOServer(httpServer, {\n      cors: {\n        origin: process.env.FRONTEND_URL || 'http://localhost:5173',\n        methods: ['GET', 'POST'],\n        credentials: true,\n      },\n      transports: ['websocket', 'polling'],\n      pingInterval: 25000,\n      pingTimeout: 20000,\n      maxHttpBufferSize: 1e6,\n    });\n\n    this.setupMiddleware();\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup authentication middleware\n   */\n  private setupMiddleware(): void {\n    this.io.use((socket, next) => {\n      try {\n        const token = socket.handshake.auth.token;\n        if (!token) {\n          return next(new Error('Authentication token required'));\n        }\n\n        const decoded = jwt.verify(\n          token,\n          process.env.JWT_SECRET || 'your-secret-key'\n        ) as any;\n\n        if (!decoded.id || !decoded.role) {\n          return next(new Error('Invalid token payload'));\n        }\n\n        (socket as AuthSocket).userId = decoded.id;\n        (socket as AuthSocket).role = decoded.role;\n        (socket as AuthSocket).restaurantId = decoded.restaurantId;\n        (socket as AuthSocket).authenticated = true;\n\n        console.log(\n          `[WebSocket] User authenticated: ${decoded.id} (${decoded.role})`\n        );\n\n        next();\n      } catch (error: any) {\n        console.error('[WebSocket] Auth error:', error.message);\n        next(new Error('Authentication failed'));\n      }\n    });\n  }\n\n  /**\n   * Setup main event handlers\n   */\n  private setupEventHandlers(): void {\n    this.io.on('connection', (socket: Socket) => {\n      const authSocket = socket as AuthSocket;\n\n      // Track connected user\n      if (!this.connectedUsers.has(authSocket.userId)) {\n        this.connectedUsers.set(authSocket.userId, new Set());\n      }\n      this.connectedUsers.get(authSocket.userId)?.add(socket.id);\n      this.userRoles.set(authSocket.userId, authSocket.role);\n\n      console.log(`[WebSocket] User ${authSocket.userId} connected (socket: ${socket.id})`);\n\n      // Send connection confirmation\n      socket.emit('connected', {\n        userId: authSocket.userId,\n        role: authSocket.role,\n        timestamp: Date.now(),\n        serverId: process.env.SERVER_ID || 'ws-server-1',\n      });\n\n      // Subscribe handler\n      socket.on('subscribe', (data) => {\n        this.handleSubscribe(authSocket, data);\n      });\n\n      // Unsubscribe handler\n      socket.on('unsubscribe', (data) => {\n        this.handleUnsubscribe(authSocket, data);\n      });\n\n      // Custom action handler (for future use)\n      socket.on('action', (data) => {\n        this.handleAction(authSocket, data);\n      });\n\n      // Error handler\n      socket.on('error', (error) => {\n        console.error(`[WebSocket] Socket error for ${authSocket.userId}:`, error);\n      });\n\n      // Disconnect handler\n      socket.on('disconnect', () => {\n        console.log(`[WebSocket] User ${authSocket.userId} disconnected`);\n        const userSockets = this.connectedUsers.get(authSocket.userId);\n        if (userSockets) {\n          userSockets.delete(socket.id);\n          if (userSockets.size === 0) {\n            this.connectedUsers.delete(authSocket.userId);\n            this.userRoles.delete(authSocket.userId);\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Handle subscription to event channels\n   */\n  private handleSubscribe(\n    socket: AuthSocket,\n    data: { type: string; data: Record<string, any> }\n  ): void {\n    const { type, data: subscriptionData } = data;\n\n    try {\n      switch (type) {\n        case 'guest_card':\n          // Subscribe to guest's own card updates\n          socket.join(`guest:${subscriptionData.guestId}`);\n          console.log(\n            `[Subscribe] ${socket.userId} joined guest:${subscriptionData.guestId}`\n          );\n          break;\n\n        case 'points_operations':\n          // Subscribe to restaurant's points operations\n          socket.join(`restaurant:${subscriptionData.restaurantId}:points`);\n          console.log(\n            `[Subscribe] ${socket.userId} joined restaurant:${subscriptionData.restaurantId}:points`\n          );\n          break;\n\n        case 'system_events':\n          // Admin only\n          if (socket.role === 'admin') {\n            socket.join('admin:events');\n            console.log(`[Subscribe] Admin ${socket.userId} joined admin:events`);\n          } else {\n            socket.emit('error', {\n              code: 'UNAUTHORIZED',\n              message: 'Only admins can subscribe to system events',\n            });\n          }\n          break;\n\n        case 'restaurant_transactions':\n          // Restaurant manager or cashier\n          if (\n            socket.role === 'restaurant' ||\n            socket.role === 'cashier'\n          ) {\n            socket.join(`restaurant:${subscriptionData.restaurantId}:transactions`);\n            console.log(\n              `[Subscribe] ${socket.userId} joined restaurant:${subscriptionData.restaurantId}:transactions`\n            );\n          } else {\n            socket.emit('error', {\n              code: 'UNAUTHORIZED',\n              message: 'Unauthorized to subscribe to transactions',\n            });\n          }\n          break;\n\n        default:\n          socket.emit('error', {\n            code: 'INVALID_SUBSCRIPTION',\n            message: `Unknown subscription type: ${type}`,\n          });\n      }\n    } catch (error) {\n      console.error('[Subscribe] Error:', error);\n      socket.emit('error', {\n        code: 'SUBSCRIBE_ERROR',\n        message: 'Failed to subscribe',\n      });\n    }\n  }\n\n  /**\n   * Handle unsubscription\n   */\n  private handleUnsubscribe(\n    socket: AuthSocket,\n    data: { type: string; data: Record<string, any> }\n  ): void {\n    const { type, data: subscriptionData } = data;\n\n    try {\n      switch (type) {\n        case 'guest_card':\n          socket.leave(`guest:${subscriptionData.guestId}`);\n          break;\n        case 'points_operations':\n          socket.leave(`restaurant:${subscriptionData.restaurantId}:points`);\n          break;\n        case 'system_events':\n          socket.leave('admin:events');\n          break;\n        case 'restaurant_transactions':\n          socket.leave(`restaurant:${subscriptionData.restaurantId}:transactions`);\n          break;\n      }\n      console.log(`[Unsubscribe] ${socket.userId} unsubscribed from ${type}`);\n    } catch (error) {\n      console.error('[Unsubscribe] Error:', error);\n    }\n  }\n\n  /**\n   * Handle custom actions\n   */\n  private handleAction(socket: AuthSocket, data: any): void {\n    try {\n      console.log(`[Action] ${socket.userId} action:`, data.action);\n      // Handle custom user actions here\n    } catch (error) {\n      console.error('[Action] Error:', error);\n      socket.emit('error', {\n        code: 'ACTION_ERROR',\n        message: 'Failed to process action',\n      });\n    }\n  }\n\n  /**\n   * Broadcast points added event\n   */\n  broadcastPointsAdded(payload: BroadcastEventPayload): void {\n    this.io\n      .to(`restaurant:${payload.restaurantId}:points`)\n      .to(`guest:${payload.guestId}`)\n      .emit('points_added', payload);\n\n    console.log('[Broadcast] Points added to', {\n      restaurant: payload.restaurantId,\n      guest: payload.guestId,\n    });\n  }\n\n  /**\n   * Broadcast points redeemed event\n   */\n  broadcastPointsRedeemed(payload: BroadcastEventPayload): void {\n    this.io\n      .to(`restaurant:${payload.restaurantId}:points`)\n      .to(`guest:${payload.guestId}`)\n      .emit('points_redeemed', payload);\n\n    console.log('[Broadcast] Points redeemed to', {\n      restaurant: payload.restaurantId,\n      guest: payload.guestId,\n    });\n  }\n\n  /**\n   * Broadcast points expired event\n   */\n  broadcastPointsExpired(payload: BroadcastEventPayload): void {\n    this.io.to(`guest:${payload.guestId}`).emit('points_expired', payload);\n\n    console.log('[Broadcast] Points expired for guest:', payload.guestId);\n  }\n\n  /**\n   * Broadcast card created event\n   */\n  broadcastCardCreated(payload: BroadcastEventPayload): void {\n    this.io.to(`guest:${payload.guestId}`).emit('card_created', payload);\n    this.io\n      .to(`restaurant:${payload.restaurantId}:points`)\n      .emit('guest_card_created', payload);\n\n    console.log('[Broadcast] Card created for guest:', payload.guestId);\n  }\n\n  /**\n   * Send notification to specific user\n   */\n  sendToUser(userId: string, event: string, data: any): void {\n    const userSockets = this.connectedUsers.get(userId);\n    if (userSockets?.size) {\n      userSockets.forEach((socketId) => {\n        this.io.to(socketId).emit(event, data);\n      });\n      console.log(`[SendToUser] ${event} sent to ${userId}`);\n    }\n  }\n\n  /**\n   * Broadcast to all connected admins\n   */\n  broadcastToAdmins(event: string, data: any): void {\n    this.io.to('admin:events').emit(event, data);\n    console.log(`[BroadcastToAdmins] ${event} broadcasted`);\n  }\n\n  /**\n   * Get server stats\n   */\n  getStats() {\n    return {\n      connectedUsers: this.connectedUsers.size,\n      totalSockets: this.io.engine.clientsCount,\n      rooms: Array.from(this.io.sockets.adapter.rooms.keys()).filter(\n        (room) => !room.startsWith('/')\n      ),\n    };\n  }\n\n  /**\n   * Get Socket.io instance for further customization\n   */\n  getInstance(): SocketIOServer {\n    return this.io;\n  }\n}\n